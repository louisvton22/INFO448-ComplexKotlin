/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package edu.uw.complexkotlin

class Library {
    fun someLibraryMethod(): Boolean {
        return true
    }
}

// write a lambda using map and fold to solve "FIZZBUZZ" for the first fifteen numbers (0..15).
// use map() to return a list with "", "FIZZ" (for 3s) or "BUZZ" (for 5s).
// use fold() to compress the array of strings down into a single string.
// the final string should look like FIZZBUZZFIZZFIZZBUZZFIZZFIZZBUZZ for 0..15.
// store this lambda into 'fizzbuzz' so that the tests can call it
//

val fizzbuzz: (IntRange) -> String =  { it ->
    it.map { when {
        it % 3 == 0 && it % 5 == 0 && it > 0 -> "FIZZBUZZ"
        it % 3 == 0 && it > 0 -> "FIZZ"
        it % 5 == 0 && it > 0 -> "BUZZ"
        else -> ""
    }
    }.fold("") {curr, prev -> "$curr$prev"}
}
// Example usage
/*
if (fizzbuzz(0..1) == "")
    println("Success!")
if (fizzbuzz(0..3) == "FIZZ")
    println("Success!")
if (fizzbuzz(0..5) == "BUZZ")
    println("Success!")
*/

// This is a utility function for your use as you choose, and as an
// example of an extension method
fun Int.times(block: () -> Unit): Unit {
    for (it in 1..this) {
        block()
    }
}

// Use this function
fun process(message: String, block: (String) -> String): String {
    return ">>> ${message}: {" + block(message) + "}"
}

val r1 = {process("FOO") {"BAR"}}

val r2 = {process("FOO") {
    var str = ""
    3.times {
        str += "WOOGA"
    }
    str
 }
}

// write an enum-based state machine between talking and thinking
enum class Philosopher {
    TALKING {
        override fun signal():Philosopher {
            return THINKING
        }

        override fun toString():String {
            return "Allow me to suggest an idea..."
        }
    },

    THINKING {
        override fun signal():Philosopher {
            return TALKING
        }

        override fun toString(): String {
            return "Deep thoughts...."
        }
    };

    abstract fun signal():Philosopher
}

// create an class "Command" that can be used as a function (provide an "invoke()" function)
// that takes a single parameter ("message" of type String)
// primary constructor should take a String argument ("prompt")
// when invoked, the Command object should return a String containing the prompt and then the message
class Command(val prompt: String) {
   operator fun invoke(message: String): String {
       return "$prompt$message"
   }
}